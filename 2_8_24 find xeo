TTThank you for that information. If U5 is returning the Window object, we need to look deeper into the code structure to find the xeokit viewer instance. Given the complex module system hinted at in the code, the viewer might be encapsulated within a closure or a module. Let's try some more targeted approaches:

1. Examine global functions:
   ```javascript
   console.log(Object.keys(window).filter(key => typeof window[key] === 'function'));
   ```
   Look for any functions that might be related to xeokit or the viewer.

2. Check for properties on the Window object that might be xeokit-related:
   ```javascript
   console.log(Object.keys(window).filter(key => 
     key.toLowerCase().includes('xeokit') || 
     key.toLowerCase().includes('viewer') ||
     key.toLowerCase().includes('model') ||
     key.toLowerCase().includes('scene')
   ));
   ```

3. Look for any objects that have xeokit-like methods:
   ```javascript
   Object.keys(window).forEach(key => {
     if (typeof window[key] === 'object' && window[key] !== null) {
       const methods = Object.keys(window[key]).filter(method => 
         method.toLowerCase().includes('camera') ||
         method.toLowerCase().includes('scene') ||
         method.toLowerCase().includes('model') ||
         method.toLowerCase().includes('render')
       );
       if (methods.length > 0) {
         console.log(`Potential xeokit object found: ${key}`, methods);
       }
     }
   });
   ```

4. Search for canvas elements and their parent containers:
   ```javascript
   const canvases = document.querySelectorAll('canvas');
   canvases.forEach(canvas => {
     console.log('Canvas:', canvas);
     console.log('Canvas parent:', canvas.parentElement);
   });
   ```

5. Look for any custom attributes on HTML elements that might be related to xeokit:
   ```javascript
   const elementsWithCustomAttrs = document.querySelectorAll('*[data-xeokit], *[data-viewer]');
   console.log('Elements with custom xeokit attributes:', elementsWithCustomAttrs);
   ```

6. Check for any AMD or CommonJS module definitions:
   ```javascript
   if (typeof define === 'function' && define.amd) {
     console.log('AMD modules detected');
   }
   if (typeof module === 'object' && module.exports) {
     console.log('CommonJS modules detected');
   }
   ```

7. Look for any immediately invoked function expressions (IIFEs) that might contain the viewer:
   ```javascript
   Object.keys(window).forEach(key => {
     if (typeof window[key] === 'object' && window[key] !== null) {
       const iifeMethods = Object.keys(window[key]).filter(method => 
         typeof window[key][method] === 'function' && 
         window[key][method].toString().includes('function')
       );
       if (iifeMethods.length > 0) {
         console.log(`Potential IIFE found: ${key}`, iifeMethods);
       }
     }
   });
   ```

After trying these approaches, look for any output that seems related to xeokit or 3D rendering. The viewer instance might be nested within one of these objects or accessible through a method call.

If you find any promising leads, let me know, and we can explore further how to interact with the viewer based on its actual location in the code structure.



Thank you for sharing the results. It appears that the search for Immediately Invoked Function Expressions (IIFEs) has revealed several potential objects, but none of them seem to be directly related to xeokit or 3D rendering. The objects found are mostly related to browser window functionality and some compression utilities (pako).

Given this information, we need to take a different approach. The xeokit viewer might be encapsulated in a way that's not easily discoverable through global objects. Here are some next steps we can try:

1. Search for xeokit-specific canvas elements:
   ```javascript
   const xeokitCanvas = document.querySelector('canvas[id^="xeokit-canvas-"]');
   console.log('Xeokit canvas:', xeokitCanvas);
   ```

2. Look for custom data attributes that might be used by xeokit:
   ```javascript
   const xeokitElements = document.querySelectorAll('[data-xeokit]');
   console.log('Elements with xeokit data attributes:', xeokitElements);
   ```

3. Check for any global functions that might be xeokit-related:
   ```javascript
   const xeokitFunctions = Object.keys(window).filter(key => 
     typeof window[key] === 'function' && 
     (key.toLowerCase().includes('xeokit') || key.toLowerCase().includes('viewer') || key.toLowerCase().includes('model'))
   );
   console.log('Potential xeokit functions:', xeokitFunctions);
   ```

4. Look for any objects with xeokit-like properties:
   ```javascript
   const xeokitObjects = Object.keys(window).filter(key => 
     typeof window[key] === 'object' && window[key] !== null &&
     (
       window[key].hasOwnProperty('scene') ||
       window[key].hasOwnProperty('camera') ||
       window[key].hasOwnProperty('model') ||
       window[key].hasOwnProperty('viewer')
     )
   );
   console.log('Potential xeokit objects:', xeokitObjects);
   ```

5. Check for any event listeners that might be related to xeokit:
   ```javascript
   const originalAddEventListener = EventTarget.prototype.addEventListener;
   EventTarget.prototype.addEventListener = function(type, listener, options) {
     if (type.includes('xeokit') || type.includes('viewer') || type.includes('model')) {
       console.log('Xeokit-related event listener:', type);
     }
     return originalAddEventListener.call(this, type, listener, options);
   };
   ```

6. Look for any React or Angular components that might be wrapping the xeokit viewer:
   ```javascript
   console.log('React:', window.React);
   console.log('Angular:', window.ng);
   ```

7. Check for any WebGL contexts that might be used by xeokit:
   ```javascript
   const canvases = document.querySelectorAll('canvas');
   canvases.forEach(canvas => {
     const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
     if (gl) {
       console.log('WebGL canvas found:', canvas);
     }
   });
   ```

If none of these approaches yield results, the xeokit viewer might be deeply nested within a closure or module system. In that case, you might need to:

1. Set breakpoints in the JavaScript debugger where you know the 3D model is being manipulated.
2. Use the debugger to step through the code and inspect variables.
3. Look for any network requests that might be loading xeokit-related resources.

Let me know if any of these approaches reveal something useful, or if you need further guidance based on what you find.

Thank you for providing that information. It's helpful to know that the canvas ID is "main-viewer" and it's using WebGL2. Let's focus on this canvas and try to interact with the xeokit viewer through it. Here are some steps and code snippets you can try in the browser console:

1. Get a reference to the canvas:

```javascript
const canvas = document.getElementById('main-viewer');
console.log('Canvas:', canvas);
```

2. Get the WebGL2 context:

```javascript
const gl = canvas.getContext('webgl2');
console.log('WebGL2 context:', gl);
```

3. Look for xeokit-related properties on the canvas or its parent elements:

```javascript
let element = canvas;
while (element) {
    console.log('Element:', element);
    console.log('xeokit properties:', Object.keys(element).filter(key => key.toLowerCase().includes('xeokit')));
    element = element.parentElement;
}
```

4. Check for any custom properties that might hold the viewer instance:

```javascript
console.log('Canvas properties:', Object.getOwnPropertyNames(canvas).filter(prop => typeof canvas[prop] === 'object' && canvas[prop] !== null));
```

5. Look for any xeokit-related event listeners on the canvas:

```javascript
const listeners = getEventListeners(canvas);
console.log('Canvas event listeners:', listeners);
```

6. Try to find the viewer instance through the canvas:

```javascript
function findXeokitViewer(obj) {
    if (obj && typeof obj === 'object') {
        if (obj.scene && obj.camera && obj.model) {
            console.log('Potential xeokit viewer found:', obj);
            return obj;
        }
        for (let key in obj) {
            const result = findXeokitViewer(obj[key]);
            if (result) return result;
        }
    }
    return null;
}

const potentialViewer = findXeokitViewer(canvas);
console.log('Potential xeokit viewer:', potentialViewer);
```

7. If the viewer is not directly accessible, you might need to trigger some actions and observe the results. For example, try to rotate or zoom the model:

```javascript
canvas.dispatchEvent(new MouseEvent('mousedown', {
    bubbles: true,
    cancelable: true,
    view: window,
    clientX: canvas.width / 2,
    clientY: canvas.height / 2
}));

canvas.dispatchEvent(new MouseEvent('mousemove', {
    bubbles: true,
    cancelable: true,
    view: window,
    clientX: (canvas.width / 2) + 100,
    clientY: (canvas.height / 2) + 100
}));

canvas.dispatchEvent(new MouseEvent('mouseup', {
    bubbles: true,
    cancelable: true,
    view: window
}));
```

8. Check for any global functions that might be used to interact with the viewer:

```javascript
const potentialFunctions = Object.keys(window).filter(key => 
    typeof window[key] === 'function' && 
    (key.toLowerCase().includes('viewer') || key.toLowerCase().includes('model') || key.toLowerCase().includes('scene'))
);
console.log('Potential interaction functions:', potentialFunctions);
```

If you find any promising leads or observe any changes in the 3D model after trying these steps, please let me know. We can then focus on the specific areas that seem to be controlling the xeokit viewer and develop more targeted strategies for interaction.


_---------------
Thank you for sharing this information. From the image, we can see that the canvas has React-related properties, which suggests that the application is using React to manage the xeokit viewer. This is valuable information for our approach.

Given that we're dealing with a React application, the xeokit viewer instance is likely managed within a React component's state or context. Direct access to the viewer might be challenging, but we can try a few React-specific approaches:

1. Access React Fiber nodes:
   ```javascript
   const reactInternals = Object.keys(canvas).find(key => key.startsWith('__reactInternalInstance$'));
   const fiber = canvas[reactInternals];
   console.log('React Fiber:', fiber);
   ```

2. Traverse the React component tree:
   ```javascript
   function findReactComponent(fiber) {
     let node = fiber;
     while (node) {
       const stateNode = node.stateNode;
       if (stateNode && stateNode.viewer) {
         console.log('Potential xeokit viewer found:', stateNode.viewer);
         return stateNode.viewer;
       }
       if (node.child) {
         node = node.child;
       } else if (node.sibling) {
         node = node.sibling;
       } else {
         while (node && !node.sibling) {
           node = node.return;
         }
         node = node ? node.sibling : null;
       }
     }
     return null;
   }
   
   const viewer = findReactComponent(fiber);
   console.log('Xeokit viewer:', viewer);
   ```

3. Look for custom events that might be used to communicate with the xeokit viewer:
   ```javascript
   const originalAddEventListener = EventTarget.prototype.addEventListener;
   EventTarget.prototype.addEventListener = function(type, listener, options) {
     console.log('Event listener added:', type);
     return originalAddEventListener.call(this, type, listener, options);
   };
   ```

4. Check for any global React components that might be wrapping the xeokit viewer:
   ```javascript
   console.log('React components:', Object.keys(window).filter(key => key.startsWith('React') || key.endsWith('Component')));
   ```

5. Look for any custom hooks or context providers that might be managing the xeokit viewer:
   ```javascript
   console.log('Custom hooks:', Object.keys(window).filter(key => key.startsWith('use') && typeof window[key] === 'function'));
   console.log('Context providers:', Object.keys(window).filter(key => key.endsWith('Provider') && typeof window[key] === 'function'));
   ```

6. Try to trigger a re-render of the component and observe changes:
   ```javascript
   const event = new Event('resize');
   window.dispatchEvent(event);
   ```

7. Look for any global store (e.g., Redux) that might be holding the viewer state:
   ```javascript
   console.log('Redux store:', window.store);
   console.log('Global state:', window.__REDUX_STATE__);
   ```

If none of these approaches yield direct access to the xeokit viewer, you might need to consider interacting with it indirectly:

1. Simulate user interactions on the canvas (mouse events, touch events).
2. Look for any exposed API methods on the global scope that might interact with the viewer.
3. Consider using browser extension development tools to inject scripts that can access the React component tree more directly.

Let me know if any of these approaches reveal useful information about the xeokit viewer, or if you need further guidance based on what you find.
