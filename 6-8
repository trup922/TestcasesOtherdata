Thank you for that information. It's helpful to know that these global objects are available. Since we see these standard window objects, but not a direct reference to the canvas or scene, we'll need to dig a bit deeper. Let's try a few approaches to locate and interact with the canvas and the 3D model:

1. First, let's try to find the canvas element:

```python
canvas = driver.execute_script("""
    return document.querySelector('canvas');
""")

if canvas:
    print("Canvas found")
else:
    print("Canvas not found")
```

2. If that works, we can try to access some properties or methods:

```python
resolution_scale = driver.execute_script("""
    var canvas = document.querySelector('canvas');
    if (canvas && canvas.resolutionScale) {
        return canvas.resolutionScale;
    }
    return null;
""")

print(f"Resolution scale: {resolution_scale}")
```

3. Let's try to find the scene object, which might be attached to the canvas or exist separately:

```python
scene = driver.execute_script("""
    if (window.scene) return 'global';
    var canvas = document.querySelector('canvas');
    if (canvas && canvas.scene) return 'canvas';
    for (var key in window) {
        if (window[key] && typeof window[key] === 'object' && window[key].canvas) {
            return key;
        }
    }
    return null;
""")

print(f"Scene found in: {scene}")
```

4. If we find the scene, we can try to interact with it:

```python
result = driver.execute_script("""
    var sceneObject;
    if (window.scene) {
        sceneObject = window.scene;
    } else {
        var canvas = document.querySelector('canvas');
        if (canvas && canvas.scene) {
            sceneObject = canvas.scene;
        } else {
            for (var key in window) {
                if (window[key] && typeof window[key] === 'object' && window[key].canvas) {
                    sceneObject = window[key];
                    break;
                }
            }
        }
    }
    
    if (sceneObject) {
        return {
            canvasWidth: sceneObject.canvas.width,
            canvasHeight: sceneObject.canvas.height,
            numObjects: sceneObject.objects ? Object.keys(sceneObject.objects).length : 'unknown'
        };
    }
    return null;
""")

if result:
    print(f"Canvas dimensions: {result['canvasWidth']}x{result['canvasHeight']}")
    print(f"Number of objects in scene: {result['numObjects']}")
else:
    print("Could not access scene properties")
```

5. To interact with the 3D model, we might need to find specific methods. Let's try to list available methods:

```python
methods = driver.execute_script("""
    var sceneObject;
    // ... (use the same logic as above to find sceneObject)
    
    if (sceneObject) {
        return Object.getOwnPropertyNames(Object.getPrototypeOf(sceneObject))
            .filter(method => typeof sceneObject[method] === 'function');
    }
    return [];
""")

print("Available methods:", methods)
```

6. If you find useful methods, you can try to call them:

```python
driver.execute_script("""
    var sceneObject;
    // ... (use the same logic as above to find sceneObject)
    
    if (sceneObject && sceneObject.someMethod) {
        sceneObject.someMethod();
    }
""")
```

These scripts attempt to locate and interact with the canvas and scene objects in various ways. They're designed to be flexible and work even if the objects aren't directly attached to the window object.

Remember to wrap these in try-except blocks to handle any JavaScript errors that might occur:

```python
try:
    result = driver.execute_script("...")
    # process result
except Exception as e:
    print(f"An error occurred: {e}")
```

If these approaches don't work, it might be necessary to inspect the application's source code or consult with the developers to understand the exact structure and how to interact with the 3D model programmatically.


Certainly! Running code in the browser console is a great way to explore the application and find available methods. Here are some code snippets you can try in the browser console to investigate the structure of the application and find useful methods:

1. Find the canvas element:

```javascript
var canvas = document.querySelector('canvas');
console.log(canvas);
```

2. Look for a global scene object:

```javascript
console.log(window.scene);
```

3. Search for objects that might contain the scene or canvas:

```javascript
Object.keys(window).forEach(key => {
    if (window[key] && typeof window[key] === 'object' && (window[key].canvas || window[key].scene)) {
        console.log('Potential scene object found:', key, window[key]);
    }
});
```

4. If you find a scene object, explore its properties and methods:

```javascript
// Replace 'scene' with the actual object name if different
console.log('Properties:', Object.keys(scene));
console.log('Methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(scene)).filter(method => typeof scene[method] === 'function'));
```

5. Check for xeokit-specific properties:

```javascript
Object.keys(window).forEach(key => {
    if (window[key] && typeof window[key] === 'object' && window[key].xeokit) {
        console.log('xeokit object found:', key, window[key]);
    }
});
```

6. Look for a viewer object:

```javascript
Object.keys(window).forEach(key => {
    if (window[key] && typeof window[key] === 'object' && window[key].scene && window[key].camera) {
        console.log('Potential viewer object found:', key, window[key]);
    }
});
```

7. If you find a viewer object, explore its methods:

```javascript
// Replace 'viewer' with the actual object name
console.log('Viewer methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(viewer)).filter(method => typeof viewer[method] === 'function'));
```

8. Check for model-related methods:

```javascript
// Replace 'viewer' or 'scene' with the actual object name
['loadModel', 'unloadModel', 'getModel', 'getModels', 'setModelVisible', 'getModelAABB'].forEach(methodName => {
    if (typeof viewer[methodName] === 'function') {
        console.log('Found method:', methodName);
    }
});
```

9. Look for camera-related methods:

```javascript
// Replace 'viewer' or 'scene' with the actual object name
['getCamera', 'setCameraPosition', 'setCameraTarget', 'getCameraPosition', 'getCameraTarget'].forEach(methodName => {
    if (typeof viewer[methodName] === 'function') {
        console.log('Found camera method:', methodName);
    }
});
```

10. Check for navigation methods:

```javascript
// Replace 'viewer' with the actual object name
['setViewFitDuration', 'setViewFitFOV', 'viewFit', 'flyTo'].forEach(methodName => {
    if (typeof viewer[methodName] === 'function') {
        console.log('Found navigation method:', methodName);
    }
});
```

Run these snippets in the browser console while your 3D application is open. They will help you discover the structure of the application and find methods that you can potentially use for automation.

Once you find useful objects or methods, you can experiment with them directly in the console. For example, if you find a `viewFit` method, you could try:

```javascript
viewer.viewFit();
```

Remember to replace `viewer` with the actual object name you discover.

After you've identified the correct objects and methods, you can then use this information to construct your Selenium scripts, using `driver.execute_script()` to call these methods or access these objects.







Certainly! Here's the JavaScript code you can run directly in your browser's console to interact with the 3D viewer based on the methods and properties we saw in the image:

1. To find the viewer object (you may need to adjust this based on how it's actually named in your application):

```javascript
function findViewer() {
    return Object.values(window).find(obj => 
        obj && typeof obj === 'object' && 
        obj._scene && obj._scene.camera &&
        typeof obj.getRTCViewMatrix === 'function'
    );
}

var viewer = findViewer();
console.log('Viewer object:', viewer);
```

2. To access and log the camera position:

```javascript
if (viewer && viewer._scene && viewer._scene.camera) {
    console.log('Camera position:', viewer._scene.camera.eye);
    console.log('Camera look at:', viewer._scene.camera.look);
    console.log('Camera up vector:', viewer._scene.camera.up);
}
```

3. To change the camera view:

```javascript
if (viewer && viewer._scene && viewer._scene.camera) {
    viewer._scene.camera.eye = [10, 10, 10];
    viewer._scene.camera.look = [0, 0, 0];
    viewer._scene.camera.up = [0, 1, 0];
    // You might need to call a method to update the view, like:
    // viewer._scene.camera.update();
    console.log('Camera view changed');
}
```

4. To use the picking functionality (if available):

```javascript
if (viewer && typeof viewer.pick === 'function') {
    var pickResult = viewer.pick({
        canvasPos: [100, 100]  // Example canvas coordinates
    });
    console.log('Picked object:', pickResult);
}
```

5. To access snap picking properties:

```javascript
if (viewer) {
    console.log('Snap pick layer number:', viewer.snapPickLayerNumber);
    console.log('Snap pick coordinate scale:', viewer.snapPickCoordinateScale);
    console.log('Snap pick origin:', viewer.snapPickOrigin);
}
```

6. To use the getRTCViewMatrix method:

```javascript
if (viewer && typeof viewer.getRTCViewMatrix === 'function') {
    var matrix = viewer.getRTCViewMatrix('someId', [0, 0, 0]);
    console.log('RTC View Matrix:', matrix);
}
```

7. To explore available methods on the viewer object:

```javascript
if (viewer) {
    console.log('Viewer methods:', 
        Object.getOwnPropertyNames(Object.getPrototypeOf(viewer))
            .filter(method => typeof viewer[method] === 'function')
    );
}
```

Remember to run the first snippet to find and assign the viewer object before running the other snippets. You may need to adjust the property and method names based on the actual implementation in your application.

These console commands will help you explore and interact with the 3D viewer directly in the browser. Once you've confirmed which methods work and how to use them, you can then translate these into Selenium commands using Python's `driver.execute_script()` method.




I apologize for the confusion. If the viewer object is undefined, it means we need to dig deeper to find the correct object. Let's try a more comprehensive approach to locate the relevant objects and methods. Here are some console commands you can run to explore the application structure:

1. Search for objects with 3D-related properties:

```javascript
function findRelevantObjects() {
    return Object.keys(window).filter(key => {
        const obj = window[key];
        return obj && typeof obj === 'object' && (
            obj.scene || 
            obj.camera || 
            obj.canvas ||
            (obj._scene && obj._scene.camera) ||
            typeof obj.getRTCViewMatrix === 'function' ||
            typeof obj.pick === 'function'
        );
    });
}

var relevantObjects = findRelevantObjects();
console.log('Potentially relevant objects:', relevantObjects);

relevantObjects.forEach(key => {
    console.log(`\nExploring object: ${key}`);
    console.log('Properties:', Object.keys(window[key]));
    console.log('Methods:', 
        Object.getOwnPropertyNames(Object.getPrototypeOf(window[key]))
            .filter(method => typeof window[key][method] === 'function')
    );
});
```

2. Look for canvas elements, which are often used for 3D rendering:

```javascript
var canvases = document.querySelectorAll('canvas');
console.log('Canvas elements found:', canvases.length);
canvases.forEach((canvas, index) => {
    console.log(`Canvas ${index}:`, canvas);
    console.log('Canvas properties:', Object.keys(canvas));
});
```

3. Search for objects with specific methods we saw in the image:

```javascript
function findObjectsWithMethods(methodNames) {
    return Object.keys(window).filter(key => {
        const obj = window[key];
        return obj && typeof obj === 'object' && 
            methodNames.some(method => typeof obj[method] === 'function');
    });
}

var methodNames = ['getRTCViewMatrix', 'getRTCPickViewMatrix', 'getNewMat'];
var objectsWithMethods = findObjectsWithMethods(methodNames);
console.log('Objects with specific methods:', objectsWithMethods);

objectsWithMethods.forEach(key => {
    console.log(`\nExploring object: ${key}`);
    console.log('Methods found:', 
        methodNames.filter(method => typeof window[key][method] === 'function')
    );
});
```

4. Look for objects with the properties we saw in the image:

```javascript
function findObjectsWithProperties(propertyNames) {
    return Object.keys(window).filter(key => {
        const obj = window[key];
        return obj && typeof obj === 'object' && 
            propertyNames.some(prop => prop in obj);
    });
}

var propertyNames = ['snapPickLayerParams', 'snapPickLayerNumber', 'snapPickCoordinateScale', 'snapPickOrigin'];
var objectsWithProperties = findObjectsWithProperties(propertyNames);
console.log('Objects with specific properties:', objectsWithProperties);

objectsWithProperties.forEach(key => {
    console.log(`\nExploring object: ${key}`);
    console.log('Properties found:', 
        propertyNames.filter(prop => prop in window[key])
    );
});
```

5. If you find any promising objects, explore them further:

```javascript
function exploreObject(obj, name = 'Object') {
    console.log(`\nExploring ${name}:`);
    console.log('Properties:', Object.keys(obj));
    console.log('Methods:', 
        Object.getOwnPropertyNames(Object.getPrototypeOf(obj))
            .filter(method => typeof obj[method] === 'function')
    );
    
    if (obj.scene || obj._scene) {
        console.log('Scene found, exploring further:');
        exploreObject(obj.scene || obj._scene, 'Scene');
    }
    
    if (obj.camera || (obj._scene && obj._scene.camera)) {
        console.log('Camera found, exploring further:');
        exploreObject(obj.camera || obj._scene.camera, 'Camera');
    }
}

// Replace 'promisingObjectName' with any object name you found from previous searches
exploreObject(window.promisingObjectName, 'PromisingObject');
```

Run these scripts in the console one by one. They will help you identify objects that might be related to the 3D viewer, even if they're not named exactly as we expected.

Once you find objects with relevant properties or methods, you can start interacting with them. For example, if you find an object with a `camera` property:

```javascript
var viewerObject = window.promisingObjectName;  // Replace with the actual object name you found
if (viewerObject && viewerObject.camera) {
    console.log('Camera position:', viewerObject.camera.position);
    viewerObject.camera.position.set(10, 10, 10);  // This syntax might vary
    console.log('New camera position:', viewerObject.camera.position);
}
```

Remember, the exact structure and method names might be different in your specific implementation. These scripts are designed to help you explore and find the correct objects and methods to interact with.
